/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-STIXIndicators.hpp>
#include <DDNAToolKit/C++/ContentLibrary/DDNA-AppLibraryManager.hpp>
#include <DDNAToolKit/C++/Network/DDNA-DownloadManager.hpp>
#include <DDNA/FS.hpp>
#include <DDNA/XLS.hpp>
#include <regex>

#define MALWARE_DEFINITIONS_URL P( "https://downloads.imazing.com/malwares.plist" )

namespace DDNA
{
    namespace MalwareActivityDetectionHelper
    {
        Core::RecursiveLock & GetLock( void )
        {
            static Core::RecursiveLock * lock;
        
            static std::once_flag f;
            
            std::call_once
            (
                f, []
                {
                    lock = new Core::RecursiveLock( P( "MalwareActivityDetectionHelperLock" ) );
                }
            );
            
            return * ( lock );
        }
    
        STIXIndicators LoadSTIXFiles( const std::string stixFolderPath, Core::Progress & progress, std::vector< MalwareCheckResult > & results, Core::Error & e )
        {
            STIXIndicators stixIndicators;
            std::vector< std::string > stixLocalPaths;
        
            // Load and parse STIX files
            Core::LockGuard l( &GetLock() );
        
            if( stixFolderPath.empty() )
            {
                // Download STIX files online
                
                FS::Path malwareDefinitionsPath;
                
                CF::Dictionary  response;
                CF::Dictionary  malwareDefinitions;
                
                bool downloadCancelled;
                
                malwareDefinitionsPath = MalwareFolderLocalPath();
                malwareDefinitionsPath /= "malware_definitions.plist";
                
                // Try to get malwate definitions online
                FS::remove( malwareDefinitionsPath.string() );
                if( DDNA::DownloadManager::getInstance()->downloadFile( MALWARE_DEFINITIONS_URL, malwareDefinitionsPath.string(), downloadCancelled, e, nullptr ) )
                {
                    malwareDefinitions = CF::Dictionary::FromPropertyList( malwareDefinitionsPath.string() );
                }
                else
                {
                    // Get hardcoded URLs
                    malwareDefinitions = CF::Dictionary() << CF::Pair( P( "stix_urls" ), CF::Array() << CF::String( P( "https://raw.githubusercontent.com/AmnestyTech/investigations/master/2021-07-18_nso/pegasus.stix2" ) ) );
                }
                
                std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );
                
                CF::Array definitionURLs = malwareDefinitions[ P( "stix_urls" ) ];
                
                for( const CF::String & definitionURL: definitionURLs )
                {
                    FS::Path stixPath;
                    
                    stixPath = MalwareFolderLocalPath();
                    stixPath /= FS::Path( Core::URI( definitionURL ).path() ).filename();
                
                    progress.message( Core::StringTemplate::replace( Core::L10N( "MalwareActivityDetectionDownloadingSTIXFile_Info" ), "file_url", definitionURL ) );
                
                    e.reset();
                    if( !DDNA::DownloadManager::getInstance()->downloadFile( definitionURL, stixPath.string(), downloadCancelled, e, nullptr ) )
                    {
                        return stixIndicators;
                    }
                    
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, "iMazing", EVENT_STIX_DOWNLOAD_INFO, "STIX file downloaded from '" + definitionURL.GetValue() + "'.", results );
                
                    stixLocalPaths.push_back( stixPath.string() );
                }
                
                // Check that we have some STIX files
                if( stixLocalPaths.empty() )
                {
                    e = { ErrorDomain, Core::Error::Code::Unknown, Core::L10N( "MalwareActivityDetectionCouldntFindSTIXFilesOnline_Info" ) };
                    
                    return stixIndicators;
                }
            }
            else
            {
                // Load STIX files from a user local folder
                progress.message( Core::L10N( "MalwareActivityDetectionLoadingSTIXFiles_Info" ) );
                        
                for( const FS::Path stixPath: FS::getDirectoryChildrenRecursively( stixFolderPath ) )
                {
                    if( stixPath.extension() == ".stix" || stixPath.extension() == ".stix2" )
                    {
                        stixLocalPaths.push_back( stixPath.string() );
                    }
                }
            
                // Check that we have some STIX files
                if( stixLocalPaths.empty() )
                {
                    e = { ErrorDomain, Core::Error::Code::Unknown, Core::StringTemplate::replace( Core::L10N( "MalwareActivityDetectionCouldntFindSTIXFilesInLocalFolder_Info" ), "stix_folder_path", stixFolderPath ) };
                    
                    return stixIndicators;
                }
            }
                                
            progress.message( Core::L10N( "MalwareActivityDetectionLoadingSTIXFiles_Info" ) );

            // Load STIX indicators
            stixIndicators = STIXIndicators( stixLocalPaths, e );

            return stixIndicators;
        }
        
        std::shared_ptr< sqlite3 > ExtractAndOpenSQLiteDB( Core::SafePointer< Backup > backup, const std::string & backupDomain, const std::string & backupPath, const std::string & malwareCheckName, std::vector< MalwareCheckResult > & results )
        {
            Core::Error e;
            
            // Extract messages DB from device's backup
            bool stopLoading = false;
        
            if( !backup->extract( backupDomain, backupPath, MalwareActivityDetectionHelper::MalwareFolderLocalPath( backup ), false, false, stopLoading, e ) )
            {
                if( e.failure() == MDError::ItemNotFound )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_BACKUP_FILE_NOT_FOUND, "'" + backupDomain + "/" + backupPath + "' (" + "File not found in the backup" + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_BACKUP_EXTRACTION_ERROR, "'" + backupDomain + "/" + backupPath + "' (" + e.message() + ").", results );
                }
                
                return nullptr;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, malwareCheckName, EVENT_EXTRACTED_FROM_BACKUP_INFO, "'" + backupDomain + "/" + backupPath + "' extracted successfully.", results );

            // Parse DB and analyze it
            {
                sqlite3 *       dbHandle;
                std::string     query;
                FS::Path        dbPath;
                CF::Array       records;
                        
                dbPath = MalwareActivityDetectionHelper::MalwareFolderLocalPath( backup );
                dbPath /= FS::Path( backupPath ).filename();

                if( sqlite3_open( dbPath.string().c_str(), &dbHandle ) != SQLITE_OK )
                {
                    std::string sqliteErr;
                
                    if( dbHandle != nullptr )
                    {
                        sqliteErr = sqlite3_errmsg( dbHandle );
                    }
                    else
                    {
                        sqliteErr = "DB Handle is null.";
                    }
                
                    e = { ErrorDomain, Core::Error::Code::Unknown, "'" + backupDomain + "/" + backupPath + "' cannot be parsed (" + sqliteErr + ")." };
                    
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_DB_QUERY_ERROR, e.message(), results );

                    return nullptr;
                }

                return std::shared_ptr< sqlite3 >
                (
                    dbHandle,
                    [ = ]( auto p )
                    {
                        // Close SQLite connection
                        sqlite3_close( p );
                        
                        // Remove local DB file once parsed
                        FS::remove( dbPath.string() );
                    }
                );
            }
        }
        
        CF::Dictionary ExtractPropertyList( Core::SafePointer< Backup > backup, const std::string & backupDomain, const std::string & backupPath, bool checkIfDictionaryIsEmpty, const std::string & malwareCheckName, std::vector< MalwareCheckResult > & results, Core::Error & e )
        {
            bool stopLoading = false;
            
            if( !backup->extract( backupDomain, backupPath, MalwareActivityDetectionHelper::MalwareFolderLocalPath( backup ), false, false, stopLoading, e ) )
            {
                if( e.failure() == MDError::ItemNotFound )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_BACKUP_FILE_NOT_FOUND, "'" + backupDomain + "/" + backupPath + "' (" + "File not found in the backup" + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_BACKUP_EXTRACTION_ERROR, "'" + backupDomain + "/" + backupPath + "' (" + e.message() + ").", results );
                }
            
                return nullptr;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, malwareCheckName, EVENT_EXTRACTED_FROM_BACKUP_INFO, "'" + backupDomain + "/" + backupPath + "' extracted successfully.", results );
            
            FS::Path path = FS::Path( MalwareActivityDetectionHelper::MalwareFolderLocalPath( backup ) )
                          / FS::Path( backupPath ).filename();
            
            Core::Defer d
            (
                [ & ]
                {
                    // Remove local plist file once parsed
                    FS::remove( path.string() );
                }
            );
            
            CF::Dictionary plist = CF::Dictionary::FromPropertyList( path.string() );
            
            if( plist.IsValid() == false )
            {
                e = { ErrorDomain, Core::Error::Code::Unknown, "'" + backupDomain + "/" + backupPath + "' cannot be parsed." };
                
                MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_PLIST_CORRUPTED_ERROR, e.message(), results );
                
                return nullptr;
            }
            
            if( checkIfDictionaryIsEmpty && plist.GetCount() == 0 )
            {
                e = { ErrorDomain, Core::Error::Code::Unknown, "'" + backupDomain + "/" + backupPath + "' dictionary is empty." };
                
                MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, malwareCheckName, EVENT_PLIST_DICT_IS_EMPTY_ERROR, e.message(), results );
                
                return nullptr;
            }
            
            return plist;
        }
        
        std::string MalwareFolderLocalPath( void )
        {
            FS::Path malwareLocalPath;
            
            malwareLocalPath = Config::getInstance()->tempFolder();
            malwareLocalPath /= "malware_definitions";
            
            FS::createDirectories( malwareLocalPath.string() );
            
            return malwareLocalPath.string();
        }
        
        std::string MalwareFolderLocalPath( Core::SafePointer< Backup > backup )
        {
            FS::Path malwareBackupLocalPath;
            
            malwareBackupLocalPath = MalwareFolderLocalPath();
            malwareBackupLocalPath /= backup->deviceUDID();
            
            FS::createDirectories( malwareBackupLocalPath.string() );
            
            return malwareBackupLocalPath.string();
        }

        bool WriteMalwareCheckResultsToLogFile( std::vector< MalwareCheckResult > & results, const std::string & logPath, bool logAsExcel, Core::Error & e )
        {
            std::sort
            (
                results.begin(),
                results.end(),
                []( const MalwareCheckResult & i, const MalwareCheckResult & j )
                {
                    if( i.timestamp() == j.timestamp() )
                    {
                        return i.sortingIndex() < j.sortingIndex();
                    }
                    
                    return i.timestamp() < j.timestamp();
                }
            );
            
            XLS::Workbook    book;
            XLS::Worksheet & sheet( book.addSheet() );
            XLS::Row       & headers( sheet.addRow() );
            
            headers += "Type";
            headers += "Severity";
            headers += "Time (UTC)";
            headers += "Event";
            headers += "Malware";
            headers += "Analyzer Module";
            headers += "Analyzer Time (UTC)";
            headers += "Description";
            
            for( const MalwareCheckResult & result: results )
            {
                XLS::Row & row( sheet.addRow() );
                
                switch( result.type() )
                {
                    case MalwareCheckResult::Type::Analyzer:
                        row += "Analyzer";
                        break;
                    case MalwareCheckResult::Type::Device:
                        row += "Device";
                        break;
                    case MalwareCheckResult::Type::Unknown:
                    default:
                        continue;
                }
                
                switch( result.severity() )
                {
                    case MalwareCheckResult::Severity::Info:
                        row += "Info";
                        break;
                    case MalwareCheckResult::Severity::Warning:
                        row += "Warning";
                        break;
                    case MalwareCheckResult::Severity::Critical:
                        row += "Critical";
                        break;
                    case MalwareCheckResult::Severity::Unknown:
                    default:
                        continue;
                }
                
                if( result.timestamp() > 0 )
                {
                    row.addDateTime( Core::DateTime( static_cast< int64_t >( result.timestamp() ), Core::DateTime::Epoch::Unix ), DDNA::Core::DateTime::TimeStyle::UTC );
                }
                else
                {
                    row += std::string( "" );
                }
                
                row += result.event();
                row += result.malwareName();
                row += result.malwareCheckName();

                if( result.creationTimestamp() > 0 )
                {
                    row.addDateTime( Core::DateTime( static_cast< int64_t >( result.creationTimestamp() ), Core::DateTime::Epoch::Unix ), DDNA::Core::DateTime::TimeStyle::UTC );
                }
                else
                {
                    row += std::string( "" );
                }

                row += result.data();
            }
                            
            if( logAsExcel )
            {
                e = book.save( logPath );
            }
            else
            {
                e = sheet.saveAsSeparatedValues( logPath, DDNA::Config::getInstance()->dataExportDelimiter() );
            }
            
            return e.success();
        }
        
        std::vector< std::string > FindLinks( std::string text )
        {
            try
            {
                std::vector< std::string > links;
                std::smatch                matches;
                std::regex                 regex = std::regex( "(https?://[^\\s]+)" );
                
                while( std::regex_search( text, matches, regex ) )
                {
                    uint64_t i = 0;
                    
                    for( const auto & link: matches )
                    {
                        if( i++ == 0 )
                        {
                            continue;
                        }
                        
                        links.push_back( link );
                    }
                    
                    text = matches.suffix();
                }
                
                return links;
            }
            catch( ... )
            {}
            
            return {};
        }
        
        std::string AppName( const std::string & bundleID )
        {
            Core::SafePointer< iOSApp > app = AppLibraryManager::anyApp( bundleID );
            if( app.isNotNull() )
            {
                return app->name();
            }
            
            return bundleID;
        }
        
        std::string AppIconPath( const std::string & bundleID )
        {
            Core::SafePointer< iOSApp > app = AppLibraryManager::anyApp( bundleID );
            if( app.isNotNull() )
            {
                return app->iconPath();
            }
            
            return "";
        }
        
        double AppleTimestampToUnixTimestamp( double appleTimestamp )
        {
            return appleTimestamp - 978307200;
        }
    }
}
