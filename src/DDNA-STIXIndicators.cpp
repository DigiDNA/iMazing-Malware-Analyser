/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-STIXIndicators.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>
#include <DDNAToolKit/C++/Network/DDNA-ProxyHelper.hpp>
#include <DDNAToolKit/C++/Base/DDNA-Log.hpp>

#include <DDNA/CK.hpp>
#include <DDNA/FS.hpp>

#include <mutex>

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif

#include <Chilkat/CkJsonObject.h>
#include <Chilkat/CkHttp.h>
#include <Chilkat/CkHttpRequest.h>
#include <Chilkat/CkHttpResponse.h>
#include <Chilkat/CkUrl.h>

#ifdef __clang__
#pragma clang diagnostic pop
#endif

namespace DDNA
{
    const char * const STIXIndicators::ErrorDomain = "com.DigiDNA.MobileDevice.STIXIndicators";

    STIXIndicators::STIXIndicators()
    {}
    
    STIXIndicators::STIXIndicators( const std::vector< std::string > & stixLocalPaths, Core::Error & error ):
        _inited( false )
    {
        CF::Dictionary malwares;
        CF::Dictionary indicators;
        CF::Dictionary relationships;
    
        // Load STIX files
        {
            CkJsonObject    stixJSON;
            CF::Dictionary  stixDict;
        
            stixJSON.put_Utf8( true );
            
            for( const std::string & stixLocalPath: stixLocalPaths )
            {
                // Load STIX JSON local file
                if( stixJSON.LoadFile( stixLocalPath.c_str() ) == false )
                {
                    error = { ErrorDomain, Core::Error::Code::Unknown, Core::StringTemplate::replace( Core::L10N( "MalwareActivityDetectionCouldntLoadSTIXFiles_Info" ), "file_path", FS::Path( stixLocalPaths[ 0 ] ).parentPath().string() ) };
                    
                    return;
                }
                
                // Load JSON JWT token in a CF dictionary
                stixDict = JSON::jsonToDictionary( stixJSON );
                
                if( stixDict.GetCount() == 0 )
                {
                    error = { ErrorDomain, Core::Error::Code::Unknown, Core::StringTemplate::replace( Core::L10N( "MalwareActivityDetectionCouldntLoadSTIXFiles_Info" ), "file_path", FS::Path( stixLocalPaths[ 0 ] ).parentPath().string() ) };
                    
                    return;
                }
                
                for( CF::Dictionary stixObject: CF::Array( stixDict[ "objects" ] ) )
                {
                    std::string type = CF::String( stixObject[ "type" ] );
                    
                    if( type == "malware" )
                    {
                        malwares << CF::Pair( stixObject[ "id" ], stixObject );
                    }
                    else if( type == "indicator" )
                    {
                        indicators << CF::Pair( stixObject[ "id" ], stixObject );
                    }
                    else if( type == "relationship" )
                    {
                        relationships << CF::Pair( stixObject[ "id" ], stixObject );
                    }
                    else
                    {
                        continue;
                    }
                }
            }
        }
    
        // Parse STIX files
        for( const auto & p: indicators )
        {
            CF::Dictionary indicator = p.GetValue();
            
            if( indicator.IsValid() == false || CF::String( indicator[ "type" ] ) != "indicator" )
            {
                continue;
            }
            
            std::string pattern              = CF::String( indicator[ "pattern" ] );
            pattern                          = Core::String::trim( pattern, "[" );
            pattern                          = Core::String::trim( pattern, "]" );
            std::vector< std::string > parts = Core::String::split( pattern, '=' );
            
            if( parts.size() < 2 )
            {
                continue;
            }
            
            std::string    key     = parts[ 0 ];
            std::string    value   = Core::String::trim( Core::String::trim( parts[ 1 ], "'" ) );
            CF::Dictionary malware = {};
            
            for( const auto & rel: relationships )
            {
                CF::Dictionary relation = rel.GetValue();
                
                if( CF::String( relation[ "source_ref" ] ) == p.GetKey() )
                {
                    malware = malwares[ CF::String( relation[ "target_ref" ] ) ];
                }
            }
            
            if( key == "domain-name:value" )
            {
                value                   = Core::String::toLower( value );
                this->_domains[ value ] = { indicator, malware };
            }
            else if( key == "process:name" )
            {
                this->_processes[ value ] = { indicator, malware };
            }
            else if( key == "email-addr:value" )
            {
                value                  = Core::String::toLower( value );
                this->_emails[ value ] = { indicator, malware };
            }
            else if( key == "file:name" )
            {
                this->_files[ value ] = { indicator, malware };
            }
            else
            {
                continue;
            }
        }
        
        #ifdef DEBUG
        this->test();
        #endif
        
        this->_inited = true;
    }
    
    STIXIndicators::STIXIndicators( const STIXIndicators & o ):
        _domains(   o._domains ),
        _processes( o._processes ),
        _emails(    o._emails ),
        _files(     o._files ),
        _inited(    o._inited )
    {}
    
    STIXIndicators::STIXIndicators( STIXIndicators && o ) noexcept:
        _domains(   std::move( o._domains ) ),
        _processes( std::move( o._processes ) ),
        _emails(    std::move( o._emails ) ),
        _files(     std::move( o._files ) ),
        _inited(    std::move( o._inited ) )
    {}
    
    STIXIndicators::~STIXIndicators()
    {}
    
    STIXIndicators & STIXIndicators::operator =( STIXIndicators o )
    {
        swap( *( this ), o );
        
        return *( this );
    }
    
    void swap( STIXIndicators & o1, STIXIndicators & o2 )
    {
        using std::swap;
        
        swap( o1._domains,   o2._domains );
        swap( o1._processes, o2._processes );
        swap( o1._emails,    o2._emails );
        swap( o1._files,     o2._files );;
        swap( o1._inited,    o2._inited );
    }
    
    void STIXIndicators::log( const std::string & message ) const
    {
        if( this->_inited == false )
        {
            return;
        }
        
        ( void )message;
        DDNALog( message );
    }
    
    #ifdef DEBUG
    void STIXIndicators::test() const
    {
        Core::Error error;
        
        if( std::get< 0 >( this->checkURL( "https://bit.ly/3x9gycC", error ) ).isSuspicious() == false && error.success() )
        {
            DDNALog( "Error checking suspicious URL: https://bit.ly/3x9gycC" );
            abort();
        }
        
        for( const auto & p: this->_domains )
        {
            std::string url = p.first;
            
            if( std::get< 0 >( this->checkURL( url, error ) ).isSuspicious() == false && error.success() )
            {
                DDNALog( "Error checking suspicious URL: " << url );
                abort();
            }
            
            url = "https://" + p.first;
            
            if( std::get< 0 >( this->checkURL( url, error ) ).isSuspicious() == false && error.success() )
            {
                DDNALog( "Error checking suspicious URL: " << url );
                abort();
            }
            
            url = "https://" + p.first + "/foo/bar";
            
            if( std::get< 0 >( this->checkURL( url, error ) ).isSuspicious() == false && error.success() )
            {
                DDNALog( "Error checking suspicious URL: " << url );
                abort();
            }
            
            url = "https://foo.bar." + p.first + "/foo/bar";
            
            if( std::get< 0 >( this->checkURL( url, error ) ).isSuspicious() == false && error.success() )
            {
                DDNALog( "Error checking suspicious URL: " << url );
                abort();
            }
        }
        
        for( const auto & p: this->_emails )
        {
            if( this->checkEmail( p.first ).isSuspicious() == false )
            {
                DDNALog( "Error checking suspicious email: " << p.first );
                abort();
            }
        }
        
        for( const auto & p: this->_processes )
        {
            if( this->checkProcess( p.first ).isSuspicious() == false )
            {
                DDNALog( "Error checking suspicious process: " << p.first );
                abort();
            }
        }
        
        for( const auto & p: this->_files )
        {
            if( this->checkFile( p.first ).isSuspicious() == false )
            {
                DDNALog( "Error checking suspicious file: " << p.first );
                abort();
            }
        }
    }
    #endif
    
    std::string STIXIndicators::unshortenURL( const std::string & value, Core::Error & error ) const
    {
        try
        {
            CkHttp        http;
            CkHttpRequest request;
            CkUrl         url;
            
            if( url.ParseUrl( value.c_str() ) == false )
            {
                error = { ErrorDomain, Core::Error::Code::Unknown, "Cannot parse URL: " + value };
                
                return {};
            }
            
            http.put_Utf8( true );
            http.put_AllowGzip( true );
            
            ProxyHelper::ConfigureHTTP( http );
            
            request.put_HttpVerb( "HEAD" );
            request.put_HttpVersion( "1.1" );
            request.put_Utf8( true );
            request.put_Charset( "utf-8" );
            request.put_SendCharset( true );
            request.SetFromUrl( value.c_str() );
            
            std::string      domain   = url.host();
            int              port     = url.get_Port();
            CkHttpResponse * res      = http.SynchronousRequest( domain.c_str(), port, port == 443, request );
            const char     * redirect = http.finalRedirectUrl();
            Core::Defer      defer    = { [ & ] { delete res; } };
            
            if( redirect == nullptr && res != nullptr )
            {
                redirect = res->finalRedirectUrl();
            }
            
            if( redirect != nullptr )
            {
                if( strlen( redirect ) == 0 )
                {
                    error = { ErrorDomain, Core::Error::Code::Unknown, "Cannot expand shortened URL: " + value };
                    
                    return {};
                }
                
                /* Nested shortened URLs */
                if( this->urlIsShortened( redirect ) )
                {
                    return this->unshortenURL( redirect, error );
                }
                
                return redirect;
            }
        }
        catch( ... )
        {}
        
        error = { ErrorDomain, Core::Error::Code::Unknown, "Cannot expand shortened URL: " + value };
        
        return {};
    }
    
    std::tuple< MalwareCheckResult, std::string > STIXIndicators::checkURL( std::string value, Core::Error & error ) const
    {
        CkUrl original;
        CkUrl check;
        
        value = Core::String::trim( value );
        
        if( value.length() == 0 )
        {
            return {};
        }
        
        std::string finalURL = value;
        
        if( original.ParseUrl( value.c_str() ) == false )
        {
            error = { ErrorDomain, Core::Error::Code::Unknown, "Cannot parse URL: " + value };
            
            return { {}, finalURL };
        }
        
        check.ParseUrl( value.c_str() );
        
        bool shortened = this->urlIsShortened( value );
        
        if( shortened )
        {
            std::string unshortened = this->unshortenURL( value, error );
            
            if( unshortened.size() == 0 )
            {
                for( const auto & p: this->_domains )
                {
                    CF::Dictionary malware = p.second.second;
                    
                    if( value.find( p.first ) != std::string::npos )
                    {
                        this->log( "Maybe found a known suspicious domain: " + p.first );
                        
                        return { { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_DOMAIN }, finalURL };
                    }
                }
                
                return { {}, finalURL };
            }
            
            finalURL = unshortened;
            
            check.ParseUrl( unshortened.c_str() );
        }
        
        std::string domain = Core::String::toLower( check.host() );
        
        for( const auto & p: this->_domains )
        {
            CF::Dictionary malware = p.second.second;
            
            if( p.first == domain )
            {
                if( shortened )
                {
                    this->log( "Found a known suspicious domain " + p.first + " shortened as " + value );
                }
                else
                {
                    this->log( "Found a known suspicious domain: " + p.first );
                }
                
                return { { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_DOMAIN }, finalURL };
            }
            
            if( domain.size() > p.first.size() && domain.find( "." + p.first ) == domain.size() - ( p.first.size() + 1 ) )
            {
                if( shortened )
                {
                    this->log( "Found a sub-domain matching a suspicious top level " + p.first + " shortened as " + value );
                }
                else
                {
                    this->log( "Found a sub-domain matching a suspicious top level: " + p.first );
                }
                
                return { { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_DOMAIN }, finalURL };
            }
        }
        
        return { {}, finalURL };
    }
    
    MalwareCheckResult STIXIndicators::checkProcess( std::string value ) const
    {
        value = Core::String::trim( value );
        
        if( value.length() == 0 )
        {
            return {};
        }
        
        FS::Path    path  = value;
        std::string check = path.filename().string();
        
        for( const auto & p: this->_processes )
        {
            CF::Dictionary malware = p.second.second;
            
            if( p.first == check )
            {
                this->log( "Found a known suspicious process name: " + p.first );
                
                return { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_PROCESS };
            }
        }
        
        if( check.length() == 16 )
        {
            for( const auto & p: this->_processes )
            {
                CF::Dictionary malware = p.second.second;
                
                if( p.first.find( check ) == 0 )
                {
                    this->log( "Found a truncated known suspicious process name: " + p.first );
                    
                    return { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_PROCESS };
                }
            }
        }
        
        return {};
    }
    
    MalwareCheckResult STIXIndicators::checkEmail( std::string value ) const
    {
        value = Core::String::trim( Core::String::toLower( value ) );
        
        if( value.length() == 0 )
        {
            return {};
        }
        
        for( const auto & p: this->_emails )
        {
            CF::Dictionary malware = p.second.second;
            
            if( p.first == value )
            {
                this->log( "Found a known suspicious email address: " + p.first );
                
                return { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_EMAIL };
            }
        }
        
        return {};
    }
    
    MalwareCheckResult STIXIndicators::checkFile( std::string value ) const
    {
        value = Core::String::trim( value );
        
        if( value.length() == 0 )
        {
            return {};
        }
        
        FS::Path    path  = value;
        std::string check = path.filename().string();
        
        for( const auto & p: this->_files )
        {
            CF::Dictionary malware = p.second.second;
            
            if( p.first == check || value.find( p.first ) == 0 )
            {
                this->log( "Found a known suspicious file: " + p.first );
                
                return { CF::String( malware[ "name" ] ), EVENT_INDICATOR_MATCH_FILE };
            }
        }
        
        return {};
    }
    
    bool STIXIndicators::urlIsShortened( const std::string & value ) const
    {
        static std::vector< std::string > * domains;
        static std::once_flag               once;
        
        std::call_once
        (
            once,
            [ & ]
            {
                domains = new std::vector< std::string >
                {
                    "1link.in",
                    "1url.com",
                    "2big.at",
                    "2pl.us",
                    "2tu.us",
                    "2ya.com",
                    "4url.cc",
                    "6url.com",
                    "a2a.me",
                    "abbrr.com",
                    "adf.ly",
                    "adjix.com",
                    "a.gg",
                    "alturl.com",
                    "a.nf",
                    "atu.ca",
                    "b23.ru",
                    "bacn.me",
                    "bit.ly",
                    "bit.do",
                    "bkite.com",
                    "bloat.me",
                    "budurl.com",
                    "buff.ly",
                    "buk.me",
                    "burnurl.com",
                    "chilp.it",
                    "clck.ru",
                    "clickmeter.com",
                    "cli.gs",
                    "c-o.in",
                    "cort.as",
                    "cut.ly",
                    "cuturl.com",
                    "decenturl.com",
                    "decenturl.com",
                    "dfl8.me",
                    "digbig.com",
                    "digg.com",
                    "doiop.com",
                    "dwarfurl.com",
                    "dy.fi",
                    "easyuri.com",
                    "easyurl.net",
                    "eepurl.com",
                    "esyurl.com",
                    "ewerl.com",
                    "fa.b",
                    "fff.to",
                    "ff.im",
                    "fhurl.com",
                    "fire.to",
                    "firsturl.de",
                    "flic.kr",
                    "fly2.ws",
                    "fon.gs",
                    "fwd4.me",
                    "gl.am",
                    "go2cut.com",
                    "go2.me",
                    "go.9nl.com",
                    "goo.gl",
                    "goshrink.com",
                    "gowat.ch",
                    "gri.ms",
                    "gurl.es",
                    "hellotxt.com",
                    "hex.io",
                    "hover.com",
                    "href.in",
                    "htxt.it",
                    "hugeurl.com",
                    "hurl.it",
                    "hurl.me",
                    "hurl.ws",
                    "icanhaz.com",
                    "idek.net",
                    "inreply.to",
                    "iscool.net",
                    "is.gd",
                    "iterasi.net",
                    "jijr.com",
                    "jmp2.net",
                    "just.as",
                    "kissa.be",
                    "kl.am",
                    "klck.me",
                    "korta.nu",
                    "krunchd.com",
                    "liip.to",
                    "liltext.com",
                    "lin.cr",
                    "linkbee.com",
                    "linkbun.ch",
                    "liurl.cn",
                    "lnk.gd",
                    "lnk.in",
                    "ln-s.net",
                    "ln-s.ru",
                    "loopt.us",
                    "lru.jp",
                    "lt.tl",
                    "lurl.no",
                    "metamark.net",
                    "migre.me",
                    "minilien.com",
                    "miniurl.com",
                    "minurl.fr",
                    "moourl.com",
                    "myurl.in",
                    "ne1.net",
                    "njx.me",
                    "nn.nf",
                    "notlong.com",
                    "nsfw.in",
                    "om.ly",
                    "ow.ly",
                    "o-x.fr",
                    "pd.am",
                    "pic.gd",
                    "ping.fm",
                    "piurl.com",
                    "pnt.me",
                    "poprl.com",
                    "posted.at",
                    "post.ly",
                    "profile.to",
                    "qicute.com",
                    "qlnk.net",
                    "quip-art.com",
                    "rb6.me",
                    "redirx.com",
                    "rickroll.it",
                    "ri.ms",
                    "riz.gd",
                    "rsmonkey.com",
                    "rubyurl.com",
                    "ru.ly",
                    "s7y.us",
                    "safe.mn",
                    "sharein.com",
                    "sharetabs.com",
                    "shorl.com",
                    "short.ie",
                    "shortlinks.co.uk",
                    "shortna.me",
                    "short.to",
                    "shorturl.com",
                    "shoturl.us",
                    "shrinkify.com",
                    "shrinkster.com",
                    "shrten.com",
                    "shrt.st",
                    "shrunkin.com",
                    "shw.me",
                    "simurl.com",
                    "sn.im",
                    "snipr.com",
                    "snipurl.com",
                    "snurl.com",
                    "sp2.ro",
                    "spedr.com",
                    "sqrl.it",
                    "starturl.com",
                    "sturly.com",
                    "su.pr",
                    "t.co",
                    "tcrn.ch",
                    "thrdl.es",
                    "tighturl.com",
                    "tiny123.com",
                    "tinyarro.ws",
                    "tiny.cc",
                    "tiny.pl",
                    "tinytw.it",
                    "tinyuri.ca",
                    "tinyurl.com",
                    "tinyvid.io",
                    "tnij.org",
                    "togoto.us",
                    "to.ly",
                    "traceurl.com",
                    "tr.im",
                    "tr.my",
                    "turo.us",
                    "tweetburner.com",
                    "twirl.at",
                    "twit.ac",
                    "twitterpan.com",
                    "twitthis.com",
                    "twiturl.de",
                    "twurl.cc",
                    "twurl.nl",
                    "u6e.de",
                    "ub0.cc",
                    "u.mavrev.com",
                    "u.nu",
                    "updating.me",
                    "ur1.ca",
                    "url4.eu",
                    "urlao.com",
                    "urlbrief.com",
                    "url.co.uk",
                    "urlcover.com",
                    "urlcut.com",
                    "urlenco.de",
                    "urlhawk.com",
                    "url.ie",
                    "urlkiss.com",
                    "urlot.com",
                    "urlpire.com",
                    "urlx.ie",
                    "urlx.org",
                    "urlzen.com",
                    "virl.com",
                    "vl.am",
                    "w3t.org",
                    "wapurl.co.uk",
                    "wipi.es",
                    "wp.me",
                    "xaddr.com",
                    "x.co",
                    "xeeurl.com",
                    "xr.com",
                    "xrl.in",
                    "xrl.us",
                    "x.se",
                    "xurl.jp",
                    "xzb.cc",
                    "yep.it",
                    "yfrog.com",
                    "yweb.com",
                    "zi.ma",
                    "zi.pe",
                    "zipmyurl.com",
                    "zz.gd",
                    "ymlp.com",
                    "forms.gle",
                    "ht.ly",
                    "lnkd.in",
                    "1drv.ms"
                };
            }
        );
        
        CkUrl url;
        
        url.ParseUrl( value.c_str() );
        
        std::string domain = url.host();
        
        return std::find( domains->begin(), domains->end(), Core::String::toLower( domain ) ) != domains->end();
    }
}
