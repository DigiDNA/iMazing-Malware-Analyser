/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionOperation.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-STIXIndicators.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareCheck.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareCheckResult.hpp>
#include <DDNAToolKit/C++/MobileDevice/Devices/DDNA-iOSDevice.hpp>
#include <DDNAToolKit/C++/MobileDevice/Backups/DDNA-Backup.hpp>
#include <DDNAToolKit/C++/UserInteraction/DDNA-UINotification.hpp>
#include <DDNAToolKit/C++/Network/DDNA-DownloadManager.hpp>
#include <DDNAToolKit/C++/Base/DDNA-Log.hpp>

namespace DDNA
{
    const char * const MalwareActivityDetectionOperation::ErrorDomain = "com.DigiDNA.MobileDevice.MalwareActivityDetectionOperation";

    MalwareActivityDetectionOperation::MalwareActivityDetectionOperation( Core::SafePointer< iOSDevice > device, bool backupDevice, const std::string & stixFolderPath, const std::string & logPath, bool logAsExcel ):
        _device( device ),
        _stixFolderPath( stixFolderPath ),
        _logPath( logPath ),
        _logAsExcel( logAsExcel )
    {
        if( this->_device.isNull() )
        {
            return;
        }
     
        this->name( "MalwareActivityDetection-" + this->_device->udid() );
        this->_progress().title( Core::StringTemplate::replace( Core::L10N( "MalwareActivityDetection_Title" ), "devicename", this->_device->name() ) );
        this->_progress().message( Core::L10N( "PleaseWait_Info" ) );
        this->_progress().indeterminate( true );
        this->_mimeType( { logAsExcel ? "xlsx" : "csv" } );
        this->_destinationPath( logPath );
        this->addOption( Options::ShowWizards );
        
        this->infoForKey( "deviceUID",      this->_device->uid() );
        this->infoForKey( "sharedID",       "MalwareActivityDetection-" + this->_device->udid() );
        this->infoForKey( "image",          "FeatureDetectSpyware" );
        this->infoForKey( "backupDevice",   backupDevice );
        this->infoForKey( "phase",          CLI::Phase::BackupDevice );
    }

    bool MalwareActivityDetectionOperation::_execute( void )
    {
        Core::Error e;
        std::vector< MalwareCheckResult > malwareCheckResults;
        FS::Path logFilePath;
        
        // Check Internet connection
        if( !DownloadManager::getInstance()->checkInternetConnection( e ) )
        {
            this->_error( e );
            
            return false;
        }
        
        // Load and parse STIX files
        this->infoForKey( "image", "FeatureDetectSpyware" );
        
        const STIXIndicators stixIndicators = MalwareActivityDetectionHelper::LoadSTIXFiles( this->_stixFolderPath, this->_progress(), malwareCheckResults, e );
        if( e.failure() )
        {
            this->_error( e );
            
            return false;
        }
        
        // Backup device
        #ifndef DEBUG
        if( this->infoForKey( "backupDevice" ).valueOr( false ) && this->_device->type() == iOSDevice::TypeiOS && this->_device->kind() == iOSDevice::KindDevice )
        {
            this->_subOperation = this->_device->backup( Backup::OptionSetNone, "", false, VersionedBackupInfo::VersionedBackupReasonDatasetRefresh, false, false );
            this->_progress().totalUnitCount( 1 );
            this->_progress().completedUnitCount( 0 );
            this->_runChild
            (
                *( this->_subOperation ),
                1,
                {
                    Operation::ChildOptions::CatchMessage,
                    Operation::ChildOptions::CatchIndeterminate
                }
            );
            
            this->_progress().indeterminate( true );
            
            if( this->error().failure() )
            {
                return false;
            }
            
            this->_waitOrExit();
        }
        
        MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, "iMazing", EVENT_DEVICE_BACKUP_INFO, "Backup completed.", malwareCheckResults );
        #endif
        
        // Decrypting backup
        if( this->_device->getSelectedBackup()->isEncrypted() )
        {
            this->_progress().message( Core::L10N( "MalwareActivityDetectionReadingBackup_Info" ) );
            this->infoForKey( "image", "BackInTime" );
        
            Core::SafePointer< MBDBFile > mbdbFile = this->_device->getSelectedBackup()->getMBDBFile( false, false, e );
            if( mbdbFile.isNull() )
            {
                this->_error( e );
                
                return false;
            }
        }
        
        MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, "iMazing", EVENT_BACKUP_PARSING_INFO, "Backup parsed.", malwareCheckResults );
        
        // Run malware checks
        {
            this->_progress().totalUnitCount( MalwareCheck::allChecks().count() );
            this->_progress().indeterminate( false );
            
            for( MalwareCheck * malwareCheck: MalwareCheck::allChecks() )
            {
                if( !malwareCheck->image().empty() )
                {
                    this->infoForKey( "image", malwareCheck->image() );
                }
                else
                {
                    this->infoForKey( "image", "com.apple.AppStore" );
                }
                
                this->_progress()++;
                
                malwareCheck->run( this->_device->getSelectedBackup(), stixIndicators, malwareCheckResults, this->_progress() );
                
                this->_waitOrExit();
                
                std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );
            }
            
            this->_progress().indeterminate( true );

            // Write CSV log and open it
            logFilePath = this->_logPath;
            logFilePath /= "Spyware-Analysis-Results-for-Device-" + this->_device->udid() + ( this->_logAsExcel ? ".xlsx" : ".csv" );

            if( !MalwareActivityDetectionHelper::WriteMalwareCheckResultsToLogFile( malwareCheckResults, logFilePath.string(), this->_logAsExcel, e ) )
            {
                this->_error( e );
                
                return false;
            }
            
            this->_addDestinationFile( logFilePath.string() );
        }
        
        // Display analysis result dialog
        {
            std::string message;
            std::string threatDetails;
            std::string eventDetails;
            uint64_t infoCount = 0;
            uint64_t warningsCount = 0;
            uint64_t criticalsCount = 0;
            std::map< std::string, uint64_t > threatCount;
            std::map< std::string, uint64_t > eventsCount;
            
            // Count number of events
            for( const MalwareCheckResult & result: malwareCheckResults )
            {
                // Count result kinds
                switch( result.severity() )
                {
                    case MalwareCheckResult::Severity::Info:
                        infoCount++;
                        break;
                    case MalwareCheckResult::Severity::Warning:
                        warningsCount++;
                        break;
                    case MalwareCheckResult::Severity::Critical:
                        criticalsCount++;
                        break;
                    case MalwareCheckResult::Severity::Unknown:
                    default:
                        break;
                }
                
                // Count events
                if( eventsCount.find( result.event() ) == eventsCount.end() )
                {
                    eventsCount[ result.event() ] = 1;
                }
                else
                {
                    eventsCount[ result.event() ] = eventsCount[ result.event() ] + 1;
                }

                // Count threats (malwares) when they are critical
                if( result.severity() == MalwareCheckResult::Severity::Critical )
                {
                    if( threatCount.find( result.malwareName() ) == threatCount.end() )
                    {
                        threatCount[ result.malwareName() ] = 1;
                    }
                    else
                    {
                        threatCount[ result.malwareName() ] = threatCount[ result.malwareName() ] + 1;
                    }
                }
            }
            
            // Build threat details
            if( threatCount.size() > 0 )
            {
                threatDetails = "\n";

                int i = 0;
                for( const auto & pair: threatCount )
                {
                    if( i > 0 )
                    {
                        threatDetails += "\n";
                    }
                
                    threatDetails += pair.first + ": " + std::to_string( pair.second );
                    
                    i++;
                }
            }
            else
            {
                threatDetails = "\nn/a";
            }
            
            // Build event details
            if( eventsCount.size() > 0 )
            {
                eventDetails = "\n";
                
                int i = 0;
                for( const auto & pair: eventsCount )
                {
                    if( i > 0 )
                    {
                        eventDetails += "\n";
                    }
                
                    eventDetails += pair.first + ": " + std::to_string( pair.second );
                    
                    i++;
                }
            }
            else
            {
                eventDetails = "\nn/a";
            }
        
            // Build dialog message
            message = Core::StringTemplate::replace
            (
                ( threatCount.size() > 0 ? Core::L10N( "MalwareActivityPositiveDetectionDialogBoxReport_Info" ) : Core::L10N( "MalwareActivityNegativeDetectionDialogBoxReport_Info" ) ),
                {
                    { "threats_count", std::to_string( threatCount.size() ) },
                    { "events_count", std::to_string( eventsCount.size() ) },
                    { "criticals_count", std::to_string( criticalsCount ) },
                    { "warnings_count", std::to_string( warningsCount ) },
                    { "info_count", std::to_string( infoCount ) },
                    { "threat_details", threatDetails },
                    { "event_details", eventDetails }
                }
            );
            
            this->infoForKey( "image", "FeatureDetectSpyware" );
            this->_progress().message( Core::L10N( "MalwareActivityDetectionAnalysisSucceeded_Info" ) );
            
            std::string title = this->_progress().title();
            
            // Show dialog after operation is succeeded
            Core::Thread<> t
            (
                [ = ]
                {
                    uint32_t clickedButton;
                    bool checkVoxValueResult = false;
                    
                    std::this_thread::sleep_for( std::chrono::milliseconds( 500 ) );
                
                    clickedButton = DialogBoxData::showMessageBox
                    (
                        DialogBoxData::StyleInformation,
                        title,
                        message,
                        checkVoxValueResult,
                        false,
                        "",
                        {
                            { 1, Core::L10N( "OK_UserReply" ) },
                            { 2, Core::L10N( "MalwareActivityDetectionOpenReport_UserAction" ) },
                            { 3, Core::L10N( "MalwareActivityDetectionRevealReport_UserAction" ) },
                        },
                        1
                    );
                
                    switch( clickedButton )
                    {
                        case 2:
                            UINotification::openFileInDefaultViewer( logFilePath.string() );
                            break;
                        case 3:
                            UINotification::revealFile( logFilePath.string() );
                            break;
                    }
                }
            );
            t.start();
        
            return true;
        }
    }

}
