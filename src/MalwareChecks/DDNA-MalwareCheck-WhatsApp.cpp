/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-WhatsApp.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN_1 "AppDomainGroup-group.net.whatsapp.WhatsApp.shared"
#define BACKUP_DOMAIN_2 "AppDomain-net.whatsapp.WhatsApp"
#define BACKUP_PATH     "ChatStorage.sqlite"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string WhatsApp::name( void ) const
        {
            return "WhatsApp";
        }
        
        std::string WhatsApp::image( void ) const
        {
            return MalwareActivityDetectionHelper::AppIconPath( "net.whatsapp.WhatsApp" );
        }
        
        std::vector< iOSDataset > WhatsApp::iOSDatasets( void ) const
        {
            return
            {
                iOSDataset::customDatasetForTemporaryExtraction
                (
                    "net.whatsapp.WhatsApp",
                    { DEVICE_PATH_WILDCARD + BACKUP_PATH },
                    {
                        {
                            BACKUP_DOMAIN_1,
                            {
                                BACKUP_PATH
                            }
                        },
                        {
                            BACKUP_DOMAIN_1,
                            {
                                BACKUP_PATH
                            }
                        }
                    }
                )
            };
        }
        
        void WhatsApp::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckWhatsApp_Info" ) );
            
            if( !backup->mbdbRecordExists( BACKUP_DOMAIN_1, BACKUP_PATH ) && !backup->mbdbRecordExists( BACKUP_DOMAIN_2, BACKUP_PATH ) )
            {
                return;
            }
            
            std::string domain = BACKUP_DOMAIN_1;
            std::string path   = BACKUP_PATH;
            
            if( !backup->mbdbRecordExists( domain, path ) )
            {
                domain = BACKUP_DOMAIN_2;
            }
            
            std::shared_ptr< sqlite3 > db = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            this->analyzeMessages( db.get(), indicators, results, domain, path );
            this->analyzeMediaItems( db.get(), indicators, results, domain, path );
        }
        
        Core::Error WhatsApp::analyzeMessages( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, const std::string & domain, const std::string & path ) const
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = "SELECT * FROM ZWAMESSAGE;";
            
            queryDict.addTransformerForColumn( "ZMESSAGEDATE", SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No WhatsApp messages to analyze.", results );
                }
                
                return {};
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " WhatsApp messages.", results );
            
            for( const auto & record: records )
            {
                for( const auto & url: MalwareActivityDetectionHelper::FindLinks( CF::String( record[ "ZTEXT" ] ) ) )
                {
                    Core::Error error    = {};
                    double      ts       = CF::Number( record[ "ZMESSAGEDATE" ] );
                    auto        check    = indicators.checkURL( url, error );
                    auto        res      = std::get< 0 >( check );
                    auto        finalURL = std::get< 1 >( check );
                    
                    if( error.failure() )
                    {
                        MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                    }
                    
                    if( res.isSuspicious() )
                    {
                        res.addToResults
                        (
                            this->name(),
                            ts,
                            "WhatsApp message with url: '" + finalURL + "'.",
                            results
                        );
                    }
                }
            }
            
            return {};
        }
        
        Core::Error WhatsApp::analyzeMediaItems( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, const std::string & domain, const std::string & path ) const
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = R"query(
                
                SELECT ZMESSAGEDATE, ZWAMEDIAITEM.ZMEDIAURL
                FROM ZWAMESSAGE
                LEFT JOIN ZWAMEDIAITEM ON ZWAMEDIAITEM.ZMESSAGE = ZWAMESSAGE.Z_PK;
                
            )query";
            
            queryDict.addTransformerForColumn( "ZMESSAGEDATE", SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No WhatsApp attachments to analyze.", results );
                }
                
                return {};
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " WhatsApp attachments", results );
            
            for( const auto & record: records )
            {
                Core::Error error    = {};
                std::string url      = CF::String( record[ "ZMEDIAURL" ] );
                double      ts       = CF::Number( record[ "ZMESSAGEDATE" ] );
                auto        check    = indicators.checkURL( url, error );
                auto        res      = std::get< 0 >( check );
                auto        finalURL = std::get< 1 >( check );
                
                if( error.failure() )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                }
                    
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "WhatsApp media item with url: '" + finalURL + "'.",
                        results
                    );
                }
            }
            
            return {};
        }
    }
}
