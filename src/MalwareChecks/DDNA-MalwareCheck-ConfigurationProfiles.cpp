/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-ConfigurationProfiles.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>
#include <DDNAToolKit/C++/MobileDevice/Datasets/Profiles/DDNA-ProfileManager.hpp>

#define BACKUP_DOMAIN "SysSharedContainerDomain-systemgroup.com.apple.configurationprofiles"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string ConfigurationProfiles::name() const
        {
            return "Configuration Profiles";
        }
        
        std::string ConfigurationProfiles::image() const
        {
            return "com.apple.Preferences";
        }
        
        std::vector< iOSDataset > ConfigurationProfiles::iOSDatasets( void ) const
        {
            return
            {
                iOSDataset::customDatasetForTemporaryExtraction
                (
                    "com.apple.configurationprofiles.profiles",
                    {
                        FOLDER_WILDCARD + "profile-*"
                    },
                    {
                        {
                            BACKUP_DOMAIN,
                            {
                                "Library/ConfigurationProfiles/profile-*"
                            }
                        }
                    }
                )
            };
        }
        
        void ConfigurationProfiles::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckConfigurationProfiles_Info" ) );
            
            Core::SafePointer< MBDBFile > mbdb = backup->mbdbFile();
            
            if( mbdb.isNull() )
            {
                return;
            }
            
            std::vector< std::pair< CF::Dictionary, int64_t > > profiles;
            
            for( const auto & record: mbdb->recordsWithDomain( BACKUP_DOMAIN ) )
            {
                if( record->fileName().find( "profile-" ) == 0 )
                {
                    Core::Error    error;
                    CF::Dictionary profile = MalwareActivityDetectionHelper::ExtractPropertyList( backup, BACKUP_DOMAIN, record->path(), false, this->name(), results, error );
                    
                    if( error.success() )
                    {
                        profiles.push_back( { profile, record->lastModified() } );
                    }
                }
            }
            
            if( profiles.size() == 0 )
            {
                MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No configuration profile to analyze.", results );
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( profiles.size() ) + " configuration profiles.", results );
            
            for( const auto & p: profiles )
            {
                CF::Dictionary     profile = p.first;
                std::string        uuid    = CF::String( profile.GetValue( "PayloadUUID" ) );
                std::string        name    = CF::String( profile.GetValue( "PayloadDisplayName" ) );
                MalwareCheckResult res     = indicators.checkProfile( uuid );
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        p.second,
                        "Found a known malicious configuration profile '" + name + "' with UUID " + uuid,
                        results
                    );
                }
                
                CF::Array      content     = profile.GetValue( "PayloadContent" );
                CF::Dictionary contentDict = content.GetValueAtIndex( 0 );
                std::string    payloadType = CF::String( contentDict.GetValue( "PayloadType" ) );
                
                if( payloadType.find( "com.apple.notificationsettings" ) != std::string::npos )
                {
                    MalwareCheckResult
                    (
                        MalwareCheckResult::Type::Device,
                        MalwareCheckResult::Severity::Warning,
                        p.second,
                        this->name(),
                        EVENT_SUSCPICIOUS_PROFILE,
                        "Found a potentially suspicious configuration profile '" + name + "' with payload type " + payloadType,
                        results
                    );
                }
            }
        }
    }
}
