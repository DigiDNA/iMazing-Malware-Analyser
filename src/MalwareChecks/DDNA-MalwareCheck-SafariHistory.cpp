/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-SafariHistory.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN_1 "AppDomain-com.apple.mobilesafari"
#define BACKUP_DOMAIN_2 "HomeDomain"
#define BACKUP_DB_PATH  "Library/Safari/History.db"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string SafariHistory::name() const
        {
            return "Safari History";
        }
        
        std::string SafariHistory::image() const
        {
            return "com.apple.mobilesafari";
        }

        void SafariHistory::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckSafariHistory_Info" ) );
            
            // Since iOS 13, Safari History is not accessible without encryption
            if( backup->iOSMajorVersion() > 12 && !backup->encrypted() )
            {
                MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_BACKUP_FILE_NOT_FOUND_ERROR, std::string( BACKUP_DB_PATH ) + " is only available when backup encryption is enabled.", results );
                
                return;
            }

            // Extract, parse and analyze DB
            std::string domain;
            std::string path = BACKUP_DB_PATH;
            
            if( backup->iOSMajorVersion() < 13 )
            {
                domain = BACKUP_DOMAIN_1;
            }
            else
            {
                domain = BACKUP_DOMAIN_2;
            }
                    
            std::shared_ptr< sqlite3 > db = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            if( db == nullptr )
            {
                return;
            }
            
            std::string                     query;
            std::vector< CF::Dictionary >   allRecords;
            SQLite::QueryDictionary         queryDict = db.get();
        
            query = R"query(
            
                SELECT
                    history_items.id,
                    history_items.url,
                    history_visits.id as visit_id,
                    history_visits.visit_time,
                    history_visits.redirect_source,
                    history_visits.redirect_destination
                FROM history_items
                JOIN history_visits ON history_visits.history_item = history_items.id
                ORDER BY history_visits.visit_time
            
            )query";
            
            queryDict.addTransformerForColumn( "visit_time", SQLite::TransformTimestampAppleSecondsToUnix );

            // Execute query
            allRecords = queryDict.executeQuery( query );
            
            if( allRecords.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Safari history entries to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( allRecords.size() ) + " Safari history entries.", results );
            
            // Analyse records
            for( const auto & record: allRecords )
            {
                // Check Safari visits against domain indicators
                {
                    Core::Error error    = {};
                    auto        check    = indicators.checkURL( CF::String( record[ "url" ] ), error );
                    int64_t     ts       = CF::Number( record[ "visit_time" ] );
                    auto        res      = std::get< 0 >( check );
                    auto        finalURL = std::get< 1 >( check );
                    
                    if( error.failure() )
                    {
                        MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                    }

                    if( res.isSuspicious() )
                    {
                        res.addToResults
                        (
                            this->name(),
                            ts,
                            "Safari visit to '" + finalURL + "'.",
                            results
                        );
                    }
                }

                // Check Safari HTTP redirection injections
                {
                    // We presume injections only happen on HTTP visits
                    if( Core::String::toLower( CF::String( record[ "url" ] ).GetValue() ).find( "http://" ) != 0 )
                    {
                        continue;
                    }
                    
                    // If there is no destination, no redirect happened
                    if( !record.ContainsKey( "redirect_destination" ) )
                    {
                        continue;
                    }

                    std::string originDomain = Core::URI( CF::String( record[ "url" ] ) ).host();
                    
                    // Remove www. from domain to not match redirections from domainname.xx to www.domainname.xx, it's otherwise too complicated to find the 2nd and 3rd level domains, explanation here: https://stackoverflow.com/questions/288810/get-the-subdomain-from-a-url
                    originDomain = Core::String::replace( originDomain, "www.", "" );

                    for( const CF::Dictionary & redirect: allRecords )
                    {
                        if( CF::Number( redirect[ "visit_id" ] ).GetSignedLongLongValue() != CF::Number( record[ "redirect_destination" ] ).GetSignedLongLongValue() )
                        {
                            continue;
                        }
                        
                        std::string redirectDomain = Core::URI( CF::String( redirect[ "url" ] ) ).host();
                        
                        redirectDomain = Core::String::replace( redirectDomain, "www.", "" );
                        
                        // If the redirect destination is the same domain as the origin, it's most likely an HTTPS upgrade.
                        if( originDomain == redirectDomain )
                        {
                            continue;
                        }

                        // Log suspicious redirection
                        MalwareCheckResult( MalwareCheckResult::Kind::Info, CF::Number( record["visit_time"] ), this->name(), EVENT_HTTP_REDIRECT_INFO, "Found HTTP redirect to different domain: '" + originDomain + "' -> '" + redirectDomain + "'.", results );

                        // Log suspicious fast redirections
                        
                        /*
                            Disabled this check, it's useful for R&D but not relevant in the context of a spyware detection tool.
                            
                            double recordTime = CF::Number( record["visit_time"] ).GetDoubleValue();
                            double redirectTime = CF::Number( redirect["visit_time"] ).GetDoubleValue();
                            double redirectElapsedTime = redirectTime - recordTime;

                            if( redirectElapsedTime < 1 )
                            {
                                MalwareCheckResult( MalwareCheckResult::Kind::Critical, CF::Number( record["visit_time"] ).GetSignedLongLongValue(), this->name(), EVENT_HTTP_REDIRECT_INFO, "Redirect took less than a second! ( " +  std::to_string( redirectElapsedTime ) + " seconds).", results );
                            }
                        */
                    }
                }
            }
        }
    }
}
