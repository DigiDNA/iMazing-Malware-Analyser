/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-DataUsage.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN   "WirelessDomain"
#define BACKUP_PATH     "Library/Databases/DataUsage.sqlite"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string DataUsage::name() const
        {
            return "Data Usage";
        }
        
        std::string DataUsage::image() const
        {
            return "com.apple.Preferences";
        }
        
        void DataUsage::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckDataUSage_Info" ) );
            
            std::string                domain = BACKUP_DOMAIN;
            std::string                path   = BACKUP_PATH;
            std::shared_ptr< sqlite3 > db     = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            SQLite::QueryDictionary queryDict = db.get();
            std::string             query     = R"query(
                
                SELECT
                    ZPROCESS.ZFIRSTTIMESTAMP as ZPROCESS_ZFIRSTTIMESTAMP,
                    ZPROCESS.ZTIMESTAMP      as ZPROCESS_ZTIMESTAMP,
                    ZPROCESS.ZPROCNAME       as ZPROCESS_ZPROCNAME,
                    ZPROCESS.ZBUNDLENAME     as ZPROCESS_ZBUNDLENAME,
                    ZPROCESS.Z_PK            as ZPROCESS_Z_PK,
                    ZLIVEUSAGE.ZWIFIIN       as ZLIVEUSAGE_ZWIFIIN,
                    ZLIVEUSAGE.ZWIFIOUT      as ZLIVEUSAGE_ZWIFIOUT,
                    ZLIVEUSAGE.ZWWANIN       as ZLIVEUSAGE_ZWWANIN,
                    ZLIVEUSAGE.ZWWANOUT      as ZLIVEUSAGE_ZWWANOUT,
                    ZLIVEUSAGE.Z_PK          as ZLIVEUSAGE_Z_PK,
                    ZLIVEUSAGE.ZHASPROCESS   as ZLIVEUSAGE_ZHASPROCESS,
                    ZLIVEUSAGE.ZTIMESTAMP    as ZLIVEUSAGE_ZTIMESTAMP
                FROM ZLIVEUSAGE
                LEFT JOIN ZPROCESS ON ZLIVEUSAGE.ZHASPROCESS = ZPROCESS.Z_PK;
                
            )query";
            
            queryDict.addTransformerForColumn( "ZPROCESS_ZFIRSTTIMESTAMP", SQLite::TransformTimestampAppleSecondsToUnix );
            queryDict.addTransformerForColumn( "ZPROCESS_ZTIMESTAMP",      SQLite::TransformTimestampAppleSecondsToUnix );
            queryDict.addTransformerForColumn( "ZLIVEUSAGE_ZTIMESTAMP",    SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No processes to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " processes.", results );
            
            for( const auto & record: records )
            {
                double ts = CF::Number( record[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                
                if( ts == 0 )
                {
                    ts = CF::Number( record[ "ZPROCESS_ZTIMESTAMP" ] );
                }
                
                std::string        name = CF::String( record[ "ZPROCESS_ZPROCNAME" ] );
                MalwareCheckResult res  = indicators.checkProcess( name );
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "Found a suspicious process name: '" + name + "'.",
                        results
                    );
                }
                
                int64_t procID = CF::Number( record[ "ZPROCESS_Z_PK" ] );
                
                if( procID == 0 )
                {
                    std::string liveProcID = CF::String( record[ "ZLIVEUSAGE_Z_PK" ] );
                    
                    name = ( name.length() > 0 ) ? name : "<unknown-deleted>";
                    ts   = CF::Number( record[ "ZLIVEUSAGE_ZTIMESTAMP" ] );
                    MalwareCheckResult
                    (
                        MalwareCheckResult::Type::Device,
                        MalwareCheckResult::Severity::Critical,
                        ts,
                        this->name(),
                        EVENT_SUSCPICIOUS_PROCESS,
                        "Found a manipulated process entry: '" + name + "' (live proc ID: " + liveProcID + ").",
                        results
                    );
                }
            }
        }
    }
}
