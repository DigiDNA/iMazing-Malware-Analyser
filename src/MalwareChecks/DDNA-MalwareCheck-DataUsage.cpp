/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-DataUsage.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN   "WirelessDomain"
#define BACKUP_PATH     "Library/Databases/DataUsage.sqlite"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string DataUsage::name( void ) const
        {
            return "Data Usage";
        }
        
        std::string DataUsage::image( void ) const
        {
            return "com.apple.Preferences";
        }
        
        std::vector< iOSDataset > DataUsage::iOSDatasets( void ) const
        {
            return
            {
                iOSDataset::customDatasetForTemporaryExtraction
                (
                    "com.apple.DataUsage",
                    { DEVICE_PATH_WILDCARD + BACKUP_PATH },
                    {
                        {
                            BACKUP_DOMAIN,
                            {
                                BACKUP_PATH
                            }
                        }
                    }
                )
            };
        }
        
        void DataUsage::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckDataUSage_Info" ) );
            
            std::string                domain = BACKUP_DOMAIN;
            std::string                path   = BACKUP_PATH;
            std::shared_ptr< sqlite3 > db     = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            SQLite::QueryDictionary queryDict = db.get();
            std::string             query     = R"query(
                
                SELECT
                    ZPROCESS.ZFIRSTTIMESTAMP as ZPROCESS_ZFIRSTTIMESTAMP,
                    ZPROCESS.ZTIMESTAMP      as ZPROCESS_ZTIMESTAMP,
                    ZPROCESS.ZPROCNAME       as ZPROCESS_ZPROCNAME,
                    ZPROCESS.ZBUNDLENAME     as ZPROCESS_ZBUNDLENAME,
                    ZPROCESS.Z_PK            as ZPROCESS_Z_PK,
                    ZLIVEUSAGE.ZWIFIIN       as ZLIVEUSAGE_ZWIFIIN,
                    ZLIVEUSAGE.ZWIFIOUT      as ZLIVEUSAGE_ZWIFIOUT,
                    ZLIVEUSAGE.ZWWANIN       as ZLIVEUSAGE_ZWWANIN,
                    ZLIVEUSAGE.ZWWANOUT      as ZLIVEUSAGE_ZWWANOUT,
                    ZLIVEUSAGE.Z_PK          as ZLIVEUSAGE_Z_PK,
                    ZLIVEUSAGE.ZHASPROCESS   as ZLIVEUSAGE_ZHASPROCESS,
                    ZLIVEUSAGE.ZTIMESTAMP    as ZLIVEUSAGE_ZTIMESTAMP
                FROM ZLIVEUSAGE
                LEFT JOIN ZPROCESS ON ZLIVEUSAGE.ZHASPROCESS = ZPROCESS.Z_PK
                UNION SELECT
                    ZPROCESS.ZFIRSTTIMESTAMP as ZPROCESS_ZFIRSTTIMESTAMP,
                    ZPROCESS.ZTIMESTAMP      as ZPROCESS_ZTIMESTAMP,
                    ZPROCESS.ZPROCNAME       as ZPROCESS_ZPROCNAME,
                    ZPROCESS.ZBUNDLENAME     as ZPROCESS_ZBUNDLENAME,
                    ZPROCESS.Z_PK            as ZPROCESS_Z_PK,
                    NULL                     as ZLIVEUSAGE_ZWIFIIN,
                    NULL                     as ZLIVEUSAGE_ZWIFIOUT,
                    NULL                     as ZLIVEUSAGE_ZWWANIN,
                    NULL                     as ZLIVEUSAGE_ZWWANOUT,
                    NULL                     as ZLIVEUSAGE_Z_PK,
                    NULL                     as ZLIVEUSAGE_ZHASPROCESS,
                    NULL                     as ZLIVEUSAGE_ZTIMESTAMP
                FROM ZPROCESS
                WHERE Z_PK NOT IN (SELECT ZHASPROCESS FROM ZLIVEUSAGE);
                
            )query";
            
            queryDict.addTransformerForColumn( "ZPROCESS_ZFIRSTTIMESTAMP", SQLite::TransformTimestampAppleSecondsToUnix );
            queryDict.addTransformerForColumn( "ZPROCESS_ZTIMESTAMP",      SQLite::TransformTimestampAppleSecondsToUnix );
            queryDict.addTransformerForColumn( "ZLIVEUSAGE_ZTIMESTAMP",    SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No processes to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " processes.", results );
            
            this->checkManipulated( records, results );
            
            records = this->checkDeleted( records, results );
            
            for( const auto & record: records )
            {
                double ts = CF::Number( record[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                
                if( ts == 0 )
                {
                    ts = CF::Number( record[ "ZPROCESS_ZTIMESTAMP" ] );
                }
                
                std::string        name = CF::String( record[ "ZPROCESS_ZPROCNAME" ] );
                MalwareCheckResult res  = indicators.checkProcess( name );
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "Found a suspicious process name: '" + name + "'.",
                        results
                    );
                }
            }
        }
        
        void DataUsage::checkManipulated( const std::vector< CF::Dictionary > & records, std::vector< MalwareCheckResult > & results )
        {
            for( const auto & record: records )
            {
                int64_t procID = CF::Number( record[ "ZPROCESS_Z_PK" ] );
                
                if( procID != 0 )
                {
                    continue;
                }
                
                std::string name       = CF::String( record[ "ZPROCESS_ZPROCNAME" ] );
                int64_t     liveProcID = CF::Number( record[ "ZLIVEUSAGE_Z_PK" ] );
                double      ts         = CF::Number( record[ "ZLIVEUSAGE_ZTIMESTAMP" ] );
                
                if( ts == 0 )
                {
                    ts = CF::Number( record[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                }
                
                if( name.length() == 0 )
                {
                    name = "<unknown-deleted>";
                }
                
                MalwareCheckResult
                (
                    MalwareCheckResult::Type::Device,
                    MalwareCheckResult::Severity::Critical,
                    ts,
                    this->name(),
                    EVENT_SUSCPICIOUS_PROCESS,
                    "Found a manipulated process entry: '" + name + "' (live proc ID: " + std::to_string( liveProcID ) + ").",
                    results
                );
            }
        }
        
        std::vector< CF::Dictionary > DataUsage::checkDeleted( std::vector< CF::Dictionary > records, std::vector< MalwareCheckResult > & results )
        {
            std::vector< int64_t >                 allProcIDs;
            std::map<    int64_t, CF::Dictionary > procsByID;
            
            for( const auto & record: records )
            {
                int64_t id      = CF::Number( record[ "ZPROCESS_Z_PK" ] );
                procsByID[ id ] = record;
                
                allProcIDs.push_back( id );
            }
            
            std::sort( allProcIDs.begin(), allProcIDs.end() );
            
            if( allProcIDs.size() == 0 )
            {
                return records;
            }
            
            int64_t        min    = allProcIDs[ 0 ];
            int64_t        max    = allProcIDs[ allProcIDs.size() - 1 ];
            int64_t        lastID = 0;
            CF::Dictionary last;
            
            for( int64_t procID = min; procID < max; procID++ )
            {
                if( std::find( allProcIDs.begin(), allProcIDs.end(), procID ) != allProcIDs.end() )
                {
                    lastID = procID;
                    last   = procsByID[ lastID ];
                    
                    continue;
                }
                
                CF::Dictionary result;
                std::string    name = std::string( "MISSING - Follows " )
                                    + CF::String( last[ "ZPROCESS_ZPROCNAME" ] ).GetValue();
                
                result << CF::Pair( CF::String( "ZPROCESS_ZFIRSTTIMESTAMP" ), last[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                result << CF::Pair( CF::String( "ZPROCESS_ZTIMESTAMP" ),      last[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                result << CF::Pair( CF::String( "ZLIVEUSAGE_ZTIMESTAMP" ),    last[ "ZPROCESS_ZFIRSTTIMESTAMP" ] );
                result << CF::Pair( CF::String( "ZPROCESS_ZPROCNAME" ),       CF::String( name ) );
                result << CF::Pair( CF::String( "ZPROCESS_Z_PK" ),            CF::Number( procID ) );
                result << CF::Pair( CF::String( "ZLIVEUSAGE_Z_PK" ),          CF::Number( procID ) );
                
                MalwareCheckResult
                (
                    MalwareCheckResult::Type::Device,
                    MalwareCheckResult::Severity::Info,
                    0,
                    this->name(),
                    EVENT_SUSCPICIOUS_PROCESS,
                    "Missing process entry: '" + std::to_string( procID ) + "' (previous process: " + CF::String( last[ "ZPROCESS_ZPROCNAME" ] ).GetValue() + ").",
                    results
                );
                
                records.push_back( result );
            }
            
            return records;
        }
    }
}
