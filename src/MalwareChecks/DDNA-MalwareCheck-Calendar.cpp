/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-Calendar.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN   "HomeDomain"
#define BACKUP_PATH     "Library/Calendar/Calendar.sqlitedb"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string Calendar::name( void ) const
        {
            return "Calendar";
        }

        std::string Calendar::image( void ) const
        {
            return "com.apple.mobilecal";
        }

        std::vector< iOSDataset > Calendar::iOSDatasets( void ) const
        {
            return
            {
                iOSDataset::customDatasetForTemporaryExtraction
                (
                    "com.apple.mobilecal.calendars",
                    { FOLDER_WILDCARD + BACKUP_PATH },
                    {
                        {
                            BACKUP_DOMAIN,
                            {
                                BACKUP_PATH
                            }
                        }
                    }
                )
            };
        }

        void Calendar::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckCalendar_Info" ) );

            std::string                domain = BACKUP_DOMAIN;
            std::string                path   = BACKUP_PATH;
            std::shared_ptr< sqlite3 > db     = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );

            if( db == nullptr )
            {
                return;
            }

            SQLite::QueryDictionary queryDict = db.get();
            std::string             query     = R"query(

                SELECT
                    CalendarItem.ROWID             as "id",
                    CalendarItem.summary           as "summary",
                    CalendarItem.description       as "description",
                    CalendarItem.start_date        as "start_date",
                    CalendarItem.end_date          as "end_date",
                    CalendarItem.all_day           as "all_day",
                    CalendarItem.calendar_id       as "calendar_id",
                    CalendarItem.organizer_id      as "organizer_id",
                    CalendarItem.url               as "url",
                    CalendarItem.last_modified     as "last_modified",
                    CalendarItem.external_id       as "external_id",
                    CalendarItem.external_mod_tag  as "external_mod_tag",
                    CalendarItem.unique_identifier as "unique_identifier",
                    CalendarItem.hidden            as "hidden",
                    CalendarItem.UUID              as "uuid",
                    CalendarItem.creation_date     as "creation_date",
                    CalendarItem.action            as "action",
                    CalendarItem.created_by_id     as "created_by_id",
                    Participant.UUID               as "participant_uuid",
                    Participant.email              as "participant_email",
                    Participant.phone_number       as "participant_phone",
                    Participant.comment            as "participant_comment",
                    Participant.last_modified      as "participant_last_modified"
                FROM CalendarItem
                LEFT JOIN Participant ON Participant.ROWID = CalendarItem.organizer_id;

            )query";

            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );

            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No calendar item to analyze.", results );
                }

                return;
            }

            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " calendat items.", results );

            for( const auto & record: records )
            {
                CF::String uuid         = record[ "uuid" ];
                CF::String email        = record[ "participant_email" ];
                CF::String summary      = record[ "summary" ];
                CF::String description  = record[ "description" ];
                CF::Number creationDate = record[ "creation_date" ];
                double     ts           = MalwareActivityDetectionHelper::AppleTimestampToUnixTimestamp( creationDate.GetDoubleValue() );
                MalwareCheckResult res  = indicators.checkEmail( email );

                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "Calendar item with a suspicious email address: '" + email.GetValue() + "'.",
                        results
                    );
                }

                // Custom check for Quadream exploit
                if( summary == CF::String( "Meeting" ) && description == CF::String( "Notes" ) )
                {
                    MalwareCheckResult
                    {
                        MalwareCheckResult::Type::Device,
                        MalwareCheckResult::Severity::Critical,
                        ts,
                        this->name(),
                        EVENT_SUSCPICIOUS_VALUE,
                        "Potential Quadream exploit event identified: " + uuid.GetValue(),
                        results
                    };
                }
            }
        }
    }
}
