/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-WebKitObservations.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_PATH "Library/WebKit/WebsiteData/ResourceLoadStatistics/observations.db"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string WebKitObservations::name() const
        {
            return "WebKit Observations";
        }
        
        std::string WebKitObservations::image() const
        {
            return "apps-blue-icon";
        }
        
        void WebKitObservations::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            for( const auto & domain: backup->getMBDBDomains() )
            {
                progress.message( Core::L10N( "MalwareActivityDetectionCheckWebKitObservations_Info" ) );
                
                if( domain.find( "AppDomain-" ) == 0 )
                {
                    std::string bundleID = domain.substr( 10 );

                    this->run( domain, bundleID, backup, indicators, results );
                }
            }
        }
        
        void WebKitObservations::run( const std::string & domain, const std::string & bundleID, Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results )
        {
            std::string path = BACKUP_PATH;
            
            if( !backup->mbdbRecordExists( domain, path ) )
            {
                return;
            }
            
            std::shared_ptr< sqlite3 > db = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            SQLite::QueryDictionary     queryDict   = db.get();
            std::string                 query       = "SELECT * FROM ObservedDomains";
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No WebKit observations to analyze in '" + MalwareActivityDetectionHelper::AppName( bundleID ) + "' (" + bundleID + ").", results );
                }
                
                return;
            }

            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " WebKit observations in '" + MalwareActivityDetectionHelper::AppName( bundleID ) + "' (" + bundleID + ").", results );

            for( const auto & record: records )
            {
                Core::Error error    = {};
                std::string url      = CF::String( record[ "registrableDomain" ] );
                double      ts       = CF::Number( record[ "lastSeen" ] );
                auto        check    = indicators.checkURL( url, error );
                auto        res      = std::get< 0 >( check );
                auto        finalURL = std::get< 1 >( check );
                
                if( error.failure() )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                }
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "WebKit access to \"" + finalURL + "\" from app: '" + MalwareActivityDetectionHelper::AppName( bundleID ) + "' (" + bundleID + ").",
                        results
                    );
                }
            }
        }
    }
}
