/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-CallHistory.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN     "HomeDomain"
#define BACKUP_PATH       "Library/CallHistoryDB/CallHistory.storedata"
#define BACKUP_DOMAIN_OLD "WirelessDomain"
#define BACKUP_PATH_OLD   "Library/CallHistory/call_history.db"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string CallHistory::name( void ) const
        {
            return "Call History";
        }
        
        std::string CallHistory::image( void ) const
        {
            return "com.apple.mobilephone";
        }
        
        std::vector< iOSDataset > CallHistory::iOSDatasets( void ) const
        {
            return
            {
                iOSDataset::customDatasetForTemporaryExtraction
                (
                    "com.apple.mobilephone.history",
                    {
                        DEVICE_PATH_WILDCARD + BACKUP_PATH,
                        DEVICE_PATH_WILDCARD + BACKUP_PATH_OLD
                    },
                    {
                        {
                            BACKUP_DOMAIN,
                            {
                                BACKUP_PATH
                            }
                        },
                        {
                            BACKUP_DOMAIN_OLD,
                            {
                                BACKUP_PATH_OLD
                            }
                        }
                    }
                )
            };
        }
        
        void CallHistory::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckCallHistory_Info" ) );
            
            // Since iOS 13, Call History is not accessible without encryption
            if( backup->iOSMajorVersion() > 12 && !backup->encrypted() )
            {
                MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_BACKUP_FILE_NOT_FOUND, std::string( BACKUP_PATH ) + " is only available when backup encryption is enabled.", results );
                
                return;
            }
            
            std::string                domain = ( backup->iOSMajorVersion() > 7 ) ? BACKUP_DOMAIN : BACKUP_DOMAIN_OLD;
            std::string                path   = ( backup->iOSMajorVersion() > 7 ) ? BACKUP_PATH   : BACKUP_PATH_OLD;
            std::shared_ptr< sqlite3 > db     = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            SQLite::QueryDictionary queryDict = db.get();
            std::string             query;
            
            if( backup->iOSMajorVersion() > 7 )
            {
                query = "SELECT ZDATE as date, ZADDRESS as address FROM ZCALLRECORD";
            }
            else
            {
                query = "SELECT date, address FROM call";
            }
            
            queryDict.addTransformerForColumn( "date", SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No calls to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " calls.", results );
            
            for( const auto & record: records )
            {
                std::string contact = CF::String( record[ "address" ] );
                double      ts      = CF::Number( record[ "date" ] );
                
                if( contact.length() == 0 )
                {
                    CF::Data address = record[ "address" ];
                    contact          = CF::AutoPointer( CFStringCreateWithBytes( nullptr, address.GetBytePtr(), address.GetLength(), kCFStringEncodingUTF8, false ) ).As< CF::String >();
                }
                
                if( contact.find( "@" ) == std::string::npos )
                {
                    continue;
                }
                
                MalwareCheckResult res = indicators.checkEmail( contact );
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "Call record with a suspicious email address: '" + contact + "'.",
                        results
                    );
                }
            }
        }
    }
}
