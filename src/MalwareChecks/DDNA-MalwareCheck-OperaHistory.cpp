/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-OperaHistory.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>
#include <DDNA/CK.hpp>

#define BACKUP_DOMAIN   "AppDomain-com.opera.OperaTouch"
#define BACKUP_DB_PATH  "Library/Application Support/Opera_Touch.sqlite"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string OperaHistory::name() const
        {
            return "Opera";
        }
        
        std::string OperaHistory::image() const
        {
            return MalwareActivityDetectionHelper::AppIconPath( "com.opera.OperaTouch" );
        }
        
        void OperaHistory::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckOperaHistory_Info" ) );

            if( !backup->mbdbRecordExists( BACKUP_DOMAIN, BACKUP_DB_PATH ) )
            {
                return;
            }

            std::shared_ptr< sqlite3 > db = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, BACKUP_DOMAIN, BACKUP_DB_PATH, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            this->analyzeIcons( db.get(), indicators, results );
            this->analyzeSites( db.get(), indicators, results );
            this->analyzeTabs(  db.get(), indicators, results );
            this->analyzeURLs(  db.get(), indicators, results );
        }
        
        void OperaHistory::analyzeIcons( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results )
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = "SELECT * FROM ZDBAMGICON";
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + std::string( BACKUP_DOMAIN ) + "/" + std::string( BACKUP_DB_PATH ) + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Opera favicons to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " Opera favicons.", results );

            for( const auto & record: records )
            {
                Core::Error error    = {};
                std::string url      = CF::String( record[ "ZHOST" ] );
                auto        check    = indicators.checkURL( url, error );
                auto        res      = std::get< 0 >( check );
                auto        finalURL = std::get< 1 >( check );
                
                if( error.failure() )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                }
                
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        0,
                        "Opera visit to '" + finalURL + "'.",
                        results
                    );
                }
            }
        }
        
        void OperaHistory::analyzeSites( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results )
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = "SELECT * FROM ZDBSITE";
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + std::string( BACKUP_DOMAIN ) + "/" + std::string( BACKUP_DB_PATH ) + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Opera sites to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " Opera sites.", results );

            for( const auto & record: records )
            {
                Core::Error error    = {};
                std::string url      = CF::String( record[ "ZHOSTNAME" ] );
                auto        check    = indicators.checkURL( url, error );
                auto        res      = std::get< 0 >( check );
                auto        finalURL = std::get< 1 >( check );
                
                if( error.failure() )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                }
                    
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        0,
                        "Opera visit to '" + finalURL + "'.",
                        results
                    );
                }
            }
        }
        
        void OperaHistory::analyzeTabs( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results )
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = "SELECT * FROM ZDBTAB";
            
            queryDict.addTransformerForColumn( "ZLASTUSED", SQLite::TransformTimestampAppleSecondsToUnix );
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + std::string( BACKUP_DOMAIN ) + "/" + std::string( BACKUP_DB_PATH ) + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Opera tabs to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " Opera tabs.", results );

            for( const auto & record: records )
            {
                {
                    Core::Error error    = {};
                    int64_t     ts       = CF::Number( record[ "ZLASTUSED" ] );
                    std::string url      = CF::String( record[ "ZCURRENTURL" ] );
                    auto        check    = indicators.checkURL( url, error );
                    auto        res      = std::get< 0 >( check );
                    auto        finalURL = std::get< 1 >( check );
                    
                    if( error.failure() )
                    {
                        MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                    }
                        
                    if( res.isSuspicious() )
                    {
                        res.addToResults
                        (
                            this->name(),
                            ts,
                            "Opera visit to '" + finalURL + "'.",
                            results
                        );
                    }
                }
                
                {
                    CF::Data     jsonData = record[ "ZHISTORY" ];
                    std::string  jsonText = CF::AutoPointer( CFStringCreateWithBytes( nullptr, jsonData.GetBytePtr(), jsonData.GetLength(), kCFStringEncodingUTF8, false ) ).As< CF::String >();
                    CkJsonObject json;
                    
                    json.put_Utf8( true );
                    json.Load( jsonText.c_str() );
                    
                    CF::Dictionary history = JSON::jsonToDictionary( json );
                    CF::Array      all;
                    
                    all.AppendArray( CF::Array( history[ "backHistory" ] ) );
                    all.AppendArray( CF::Array( history[ "forwardHistory" ] ) );
                    
                    for( CF::Dictionary site: all )
                    {
                        Core::Error error    = {};
                        std::string url      = CF::String( site[ "url" ] );
                        auto        check    = indicators.checkURL( url, error );
                        auto        res      = std::get< 0 >( check );
                        auto        finalURL = std::get< 1 >( check );
                        
                        if( error.failure() )
                        {
                            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                        }
                            
                        if( res.isSuspicious() )
                        {
                            res.addToResults
                            (
                                this->name(),
                                0,
                                "Opera visit to '" + finalURL + "'.",
                                results
                            );
                        }
                    }
                }
            }
        }
        
        void OperaHistory::analyzeURLs( sqlite3 * db, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results )
        {
            SQLite::QueryDictionary queryDict = db;
            std::string             query     = "SELECT * FROM ZDBURL";
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + std::string( BACKUP_DOMAIN ) + "/" + std::string( BACKUP_DB_PATH ) + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Opera URLs to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " Opera URLs.", results );

            for( const auto & record: records )
            {
                Core::Error error    = {};
                std::string url      = CF::String( record[ "ZURL" ] );
                auto        check    = indicators.checkURL( url, error );
                auto        res      = std::get< 0 >( check );
                auto        finalURL = std::get< 1 >( check );
                
                if( error.failure() )
                {
                    MalwareCheckResult( MalwareCheckResult::Kind::AnalysisInfo, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                }
                    
                if( res.isSuspicious() )
                {
                    res.addToResults
                    (
                        this->name(),
                        0,
                        "Opera visit to '" + finalURL + "'.",
                        results
                    );
                }
            }
        }
    }
}
