/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-EdgeFavicon.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN   "AppDomain-com.microsoft.msedge"
#define BACKUP_DB_PATH  "Library/Application Support/ChromeSync/Favicons"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string EdgeFavicon::name() const
        {
            return "Edge Favicon";
        }
        
        std::string EdgeFavicon::image() const
        {
            return MalwareActivityDetectionHelper::AppIconPath( "com.microsoft.msedge" );
        }
        
        void EdgeFavicon::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckEdgeFavicon_Info" ) );

            if( !backup->mbdbRecordExists( BACKUP_DOMAIN, BACKUP_DB_PATH ) )
            {
                return;
            }

            std::string                domain = BACKUP_DOMAIN;
            std::string                path   = BACKUP_DB_PATH;
            std::shared_ptr< sqlite3 > db     = MalwareActivityDetectionHelper::ExtractAndOpenSQLiteDB( backup, domain, path, this->name(), results );
            
            if( db == nullptr )
            {
                return;
            }
            
            SQLite::QueryDictionary queryDict = db.get();
            std::string             query     = R"query(
                
                SELECT
                    icon_mapping.page_url,
                    favicons.url,
                    favicon_bitmaps.last_updated,
                    favicon_bitmaps.last_requested
                FROM icon_mapping
                JOIN favicon_bitmaps ON icon_mapping.icon_id = favicon_bitmaps.icon_id
                JOIN favicons ON icon_mapping.icon_id = favicons.id
                ORDER BY icon_mapping.id;
                
            )query";
            
            std::vector< CF::Dictionary > records = queryDict.executeQuery( query );
            
            if( records.size() == 0 )
            {            
                if( queryDict.errorMessage().length() > 0 )
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_DB_QUERY_ERROR, "'" + domain + "/" + path + "' cannot be parsed (" +  queryDict.errorMessage() + ").", results );
                }
                else
                {
                    MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "No Edge favicons to analyze.", results );
                }
                
                return;
            }
            
            MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Info, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, "Analyzing " + std::to_string( records.size() ) + " Edge favicons.", results );

            for( const auto & record: records )
            {
                int64_t        requested = CF::Number( record[ "last_requested" ] );
                int64_t        updated   = CF::Number( record[ "last_updated" ] );
                int64_t        ts        = ( updated != 0 ) ? updated : requested;
                Core::DateTime dt        = Core::DateTime( ts / 1000000, Core::DateTime::Epoch::Windows );
                
                for( const auto & url: std::vector< std::string > { CF::String( record[ "page_url" ] ), CF::String( record[ "url" ] ) } )
                {
                    Core::Error error    = {};
                    auto        check    = indicators.checkURL( url, error );
                    auto        res      = std::get< 0 >( check );
                    auto        finalURL = std::get< 1 >( check );
                    
                    if( error.failure() )
                    {
                        MalwareCheckResult( MalwareCheckResult::Type::Analyzer, MalwareCheckResult::Severity::Warning, 0, this->name(), EVENT_ANALYSING_ITEMS_INFO, error.message(), results );
                    }
                    
                    if( res.isSuspicious() )
                    {
                        res.addToResults
                        (
                            this->name(),
                            dt.as( Core::DateTime::Epoch::Unix ),
                            "Edge visit to '" + finalURL + "'",
                            results
                        );
                    }
                }
            }

        }
    }
}
