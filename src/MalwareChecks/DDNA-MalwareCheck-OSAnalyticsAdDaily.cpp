/*******************************************************************************
 * Copyright (c) 2021, DigiDNA
 * All rights reserved
 *
 * This Source Code Form is subject to the terms of the MVT License, v. 1.1.
 * If a copy of the MVT License was not distributed with this file, you can
 * obtain one at https://license.mvt.re/1.1/.
 ******************************************************************************/

#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/MalwareChecks/DDNA-MalwareCheck-OSAnalyticsAdDaily.hpp>
#include <DDNAToolKit/C++/MobileDevice/Diagnostics/MalwareActivityChecker/DDNA-MalwareActivityDetectionHelper.hpp>

#define BACKUP_DOMAIN   "HomeDomain"
#define BACKUP_PATH     "Library/Preferences/com.apple.osanalytics.addaily.plist"

namespace DDNA
{
    namespace MalwareChecks
    {
        std::string OSAnalyticsAdDaily::name() const
        {
            return "OS Analytics";
        }
        
        std::string OSAnalyticsAdDaily::image() const
        {
            return "com.apple.Preferences";
        }
        
        void OSAnalyticsAdDaily::run( Core::SafePointer< Backup > backup, const STIXIndicators & indicators, std::vector< MalwareCheckResult > & results, Core::Progress & progress )
        {
            progress.message( Core::L10N( "MalwareActivityDetectionCheckOSAnalyticsAdDaily_Info" ) );
            
            Core::Error    error = {};
            CF::Dictionary plist = MalwareActivityDetectionHelper::ExtractPropertyList( backup, BACKUP_DOMAIN, BACKUP_PATH, true, this->name(), results, error );
            
            if( error.failure() )
            {
                return;
            }
            
            CF::Dictionary usage = plist[ "netUsageBaseline" ];
            
            for( CF::Pair p: usage )
            {
                CF::String app = p.GetKey();
                
                if( app.IsValid() == false )
                {
                    continue;
                }
                
                MalwareCheckResult res = indicators.checkProcess( app );
                
                if( res.isSuspicious() )
                {
                    CF::Array values = p.GetValue();
                    CF::Date  date   = values[ 0 ];
                    int64_t   ts     = 0;
                    
                    if( date.IsValid() )
                    {
                        ts = Core::DateTime( static_cast< int64_t >( date.GetValue() ), Core::DateTime::Epoch::Apple );
                    }
                    
                    res.addToResults
                    (
                        this->name(),
                        ts,
                        "Found a suspicious process name: '" + app.GetValue() + "'.",
                        results
                    );
                }
            }
        }
    }
}
